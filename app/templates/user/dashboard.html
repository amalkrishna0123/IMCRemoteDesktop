{% extends 'base.html' %}
{% load static %}
{% block content %}
<div class="space-y-8">
    <div class="bg-white rounded-lg shadow-lg p-8">
        <h2 class="text-2xl font-bold mb-4">Your User ID: <span class="text-purple-600">{{ user_id }}</span></h2>
        
        {% if active_rooms %}
            {% for room in active_rooms %}
            <div data-room-id="{{ room.room_id }}" 
                 data-is-creator="{% if room.creator.id == request.user.id %}true{% else %}false{% endif %}"
                 class="space-y-4">
                <p class="text-lg">Connected to: 
                    <span class="font-bold">
                        {% if room.creator == request.user %}
                            {{ room.receiver.user_id }}
                        {% else %}
                            {{ room.creator.user_id }}
                        {% endif %}
                    </span>
                </p>
                <div class="flex space-x-4 items-center">
                    <div id="remote-screen" class="w-full h-[600px] bg-gray-100 rounded-lg mb-4">
                        <video id="remote-video" autoplay playsinline class="w-full h-full object-contain"></video>
                    </div>
                </div>
                <div id="connection-status"></div>
                <div class="flex space-x-4">
                    <button id="control-toggle" onclick="toggleRemoteControl()" 
                            class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Enable Remote Control
                    </button>
                    <a href="{% url 'end_room' room_id=room.room_id %}" 
                       class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline text-center">
                        End Session
                    </a>
                </div>
            </div>
            {% endfor %}
        {% else %}
        <div class="space-y-4">
            <div>
                <label class="block text-gray-700 text-sm font-bold mb-2" for="receiver_id">
                    Connect to User ID
                </label>
                <input class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" 
                       id="receiver_id" type="text" maxlength="10" placeholder="Enter 10-digit User ID">
            </div>
            <button id="createRoomButton" 
                    class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Create Room
            </button>
        </div>
        {% endif %}

        {% if pending_invitations %}
        <div class="mt-8">
            <h3 class="text-xl font-bold mb-4">Pending Screen Share Requests</h3>
            <div class="space-y-2">
                {% for invitation in pending_invitations %}
                <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg">
                    <p>From: {{ invitation.creator.user_id }}</p>
                    <div class="space-x-2">
                        <button onclick="acceptRoom('{{ invitation.room_id }}')" 
                                class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded">
                            Accept
                        </button>
                        <button onclick="rejectRoom('{{ invitation.room_id }}')" 
                                class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded">
                            Reject
                        </button>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
        {% endif %}
    </div>
</div>

<script>
const state = {
    peerConnection: null,
    roomSocket: null,
    isControlEnabled: false
};

const configuration = {
    iceServers: [{
        urls: 'stun:stun.l.google.com:19302'
    }]
};

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function initializeWebSocket(roomId) {
    // Determine protocol (ws:// for http, wss:// for https)
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const ws = new WebSocket(
        `${protocol}${window.location.host}/ws/room/${roomId}/`
    );

    ws.onopen = () => {
        console.log('WebSocket connected for room:', roomId);
        state.roomSocket = ws;
    };

    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateConnectionStatus('Connection failed. Please check your connection.', roomId);
    };

    ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code, event.reason);
        updateConnectionStatus('Connection closed. Trying to reconnect...', roomId);
        // Optional: Implement reconnection logic
        setTimeout(() => {
            console.log('Attempting to reconnect...');
            state.roomSocket = initializeWebSocket(roomId);
        }, 3000);
    };

    ws.onmessage = async (event) => {
        try {
            const data = JSON.parse(event.data);
            console.log('Received message:', data.type);
            
            switch (data.type) {
                case 'webrtc.offer':
                    await handleOffer(data);
                    break;
                case 'webrtc.answer':
                    await handleAnswer(data);
                    break;
                case 'ice_candidate':
                    await handleIceCandidate(data);
                    break;
                default:
                    console.log('Unhandled message type:', data.type);
            }
        } catch (error) {
            console.error('Error handling message:', error);
        }
    };

    return ws;
}

// Helper function to update connection status
function updateConnectionStatus(message, roomId) {
    const statusElement = document.querySelector(`[data-room-id="${roomId}"] #connection-status`);
    if (statusElement) {
        statusElement.textContent = message;
    }
}

async function handleOffer(data) {
    try {
        await state.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await state.peerConnection.createAnswer();
        await state.peerConnection.setLocalDescription(answer);
        
        state.roomSocket.send(JSON.stringify({
            type: 'webrtc.answer',
            answer: answer,
            roomId: data.roomId
        }));
    } catch (error) {
        console.error('Error handling offer:', error);
    }
}

async function handleAnswer(data) {
    try {
        await state.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    } catch (error) {
        console.error('Error handling answer:', error);
    }
}

async function handleIceCandidate(data) {
    try {
        await state.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
    } catch (error) {
        console.error('Error handling ICE candidate:', error);
    }
}

function toggleRemoteControl() {
    const remoteScreen = document.getElementById('remote-screen');
    const toggleButton = document.getElementById('control-toggle');
    
    state.isControlEnabled = !state.isControlEnabled;
    toggleButton.textContent = state.isControlEnabled ? 'Disable Remote Control' : 'Enable Remote Control';
    
    if (state.isControlEnabled) {
        setupRemoteControl(remoteScreen);
    } else {
        removeRemoteControl(remoteScreen);
    }
}

function setupRemoteControl(remoteScreen) {
    remoteScreen.addEventListener('mousemove', handleMouseMove);
    remoteScreen.addEventListener('mousedown', handleMouseDown);
    remoteScreen.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
}

function removeRemoteControl(remoteScreen) {
    remoteScreen.removeEventListener('mousemove', handleMouseMove);
    remoteScreen.removeEventListener('mousedown', handleMouseDown);
    remoteScreen.removeEventListener('mouseup', handleMouseUp);
    document.removeEventListener('keydown', handleKeyDown);
    document.removeEventListener('keyup', handleKeyUp);
}

function handleMouseMove(e) {
    if (!state.isControlEnabled || !state.roomSocket) return;
    
    const rect = e.target.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    
    state.roomSocket.send(JSON.stringify({
        type: 'screen_data',
        data: {
            type: 'mouse',
            action: 'move',
            x: Math.round(x * screen.width),
            y: Math.round(y * screen.height)
        }
    }));
}

function handleMouseDown(e) {
    if (!state.isControlEnabled || !state.roomSocket) return;
    
    state.roomSocket.send(JSON.stringify({
        type: 'screen_data',
        data: {
            type: 'mouse',
            action: 'down',
            button: e.button
        }
    }));
}

function handleMouseUp(e) {
    if (!state.isControlEnabled || !state.roomSocket) return;
    
    state.roomSocket.send(JSON.stringify({
        type: 'screen_data',
        data: {
            type: 'mouse',
            action: 'up',
            button: e.button
        }
    }));
}

function handleKeyDown(e) {
    if (!state.isControlEnabled || !state.roomSocket) return;
    
    state.roomSocket.send(JSON.stringify({
        type: 'screen_data',
        data: {
            type: 'keyboard',
            action: 'down',
            key: e.key
        }
    }));
}

function handleKeyUp(e) {
    if (!state.isControlEnabled || !state.roomSocket) return;
    
    state.roomSocket.send(JSON.stringify({
        type: 'screen_data',
        data: {
            type: 'keyboard',
            action: 'up',
            key: e.key
        }
    }));
}

async function initializeConnection(roomId) {
    state.peerConnection = new RTCPeerConnection(configuration);
    
    state.peerConnection.ontrack = (event) => {
        const remoteVideo = document.getElementById('remote-video');
        if (remoteVideo && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
        }
    };
    
    state.peerConnection.onicecandidate = (event) => {
        if (event.candidate && state.roomSocket) {
            state.roomSocket.send(JSON.stringify({
                type: 'ice_candidate',
                candidate: event.candidate,
                roomId: roomId
            }));
        }
    };
}

async function acceptRoom(roomId) {
    try {
        const response = await fetch(`/accept-room/${roomId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert(data.error || 'Failed to accept room');
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Failed to accept room');
    }
}

async function rejectRoom(roomId) {
    try {
        const response = await fetch(`/reject-room/${roomId}/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        if (data.success) {
            window.location.reload();
        } else {
            alert(data.error || 'Failed to reject room');
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Failed to reject room');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const roomContainers = document.querySelectorAll('[data-room-id]');
    roomContainers.forEach(container => {
        const roomId = container.dataset.roomId;
        initializeConnection(roomId);
        initializeWebSocket(roomId);
    });

    const createRoomButton = document.getElementById('createRoomButton');
    if (createRoomButton) {
        createRoomButton.addEventListener('click', async () => {
            const receiverId = document.getElementById('receiver_id').value;
            if (!receiverId || receiverId.length !== 10) {
                alert('Please enter a valid 10-digit User ID');
                return;
            }

            try {
                const response = await fetch('/create-room/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'),
                    },
                    body: JSON.stringify({
                        receiver_id: receiverId,
                    }),
                });

                const data = await response.json();
                if (data.success) {
                    window.location.reload();
                } else {
                    alert(data.error || 'Failed to create room');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while creating the room');
            }
        });
    }
});
</script>
{% endblock %}